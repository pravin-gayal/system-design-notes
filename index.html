<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Design Interview Notes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 10px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }
        
        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            overflow-x: auto;
        }
        
        .tab-button {
            flex: 1;
            min-width: 200px;
            padding: 7px 15px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }
        
        .tab-button:hover {
            background: #e9ecef;
            color: #2c3e50;
        }
        
        .tab-button.active {
            background: white;
            color: #2c3e50;
            border-bottom-color: #3498db;
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            animation: fadeIn 0.3s ease-in;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .chapter-title {
            color: #2c3e50;
            font-size: 1.5rem;
            margin-bottom: 10px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 5px;
        }
        
        .section {
            margin-bottom: 10px;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 12px;
            border-left: 5px solid #3498db;
            border-bottom: 2px solid #3498db;
        }
        
        .section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        
        .section h3::before {
            content: "▶";
            color: #3498db;
            margin-right: 10px;
            font-size: 1rem;
        }
        
        .key-points {
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .key-points ul {
            list-style: none;
            padding-left: 0;
        }
        
        .key-points li {
            padding: 8px 0;
            border-bottom: 1px solid #eee;
            position: relative;
            padding-left: 25px;
        }
        
        .key-points li::before {
            content: "✓";
            color: #27ae60;
            font-weight: bold;
            position: absolute;
            left: 0;
        }
        
        .key-points li:last-child {
            border-bottom: none;
        }
        
        .formula {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            text-align: center;
            font-weight: bold;
            color: #856404;
        }
        
        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #ff6b6b;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-top: 4px solid #e74c3c;
        }
        
        .metric-card h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .metric-card p {
            color: #666;
            line-height: 1.5;
        }
        
        .architecture-pattern {
            background: #e8f4f8;
            border: 2px solid #3498db;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .pros, .cons {
            padding: 20px;
            border-radius: 10px;
        }
        
        .pros {
            background: #d4edda;
            border-left: 5px solid #28a745;
        }
        
        .cons {
            background: #f8d7da;
            border-left: 5px solid #dc3545;
        }
        
        .pros h4, .cons h4 {
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        .pros h4 {
            color: #155724;
        }
        
        .cons h4 {
            color: #721c24;
        }
        
        @media (max-width: 768px) {
            .tabs {
                flex-direction: column;
            }
            
            .tab-button {
                min-width: auto;
            }
            
            .pros-cons {
                grid-template-columns: 1fr;
            }
            
            .metrics {
                grid-template-columns: 1fr;
            }
            
            .tab-content {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>System Design Interview Notes</h1>
            <p>Key concepts and patterns for technical interviews</p>
        </div>
        
        <div class="tabs">
            <button class="tab-button active" onclick="showTab('chapter1')">1: Scale</button>
            <button class="tab-button" onclick="showTab('chapter2')">2: Estimation</button>
            <button class="tab-button" onclick="showTab('chapter3')">3: Framework</button>
            <button class="tab-button" onclick="showTab('chapter4')">4: Rate Limiter</button>
            <button class="tab-button" onclick="showTab('chapter5')">5: Consistent Hashing</button>
            <button class="tab-button" onclick="showTab('chapter6')">6: Key-Value Store</button>
            <button class="tab-button" onclick="showTab('chapter7')">7: Unique ID Generator</button>
            <button class="tab-button" onclick="showTab('chapter8')">8: URL Shortener</button>
            <button class="tab-button" onclick="showTab('chapter9')">9: Web Crawler</button>
            <button class="tab-button" onclick="showTab('chapter10')">10: Notification System</button>
            <button class="tab-button" onclick="showTab('chapter11')">11: Design a News Feed System</button>
            <button class="tab-button" onclick="showTab('chapter12')">12: Design a Chat System</button>
            <button class="tab-button" onclick="showTab('chapter13')">13: Design a Search Autocomplete System</button>
            <button class="tab-button" onclick="showTab('chapter14')">14: Design YouTube</button>
            <button class="tab-button" onclick="showTab('chapter15')">15: Design Google Drive</button>
        </div>
        
        <div id="chapter1" class="tab-content active">
            <h2 class="chapter-title">Chapter 1: Scale from Zero to Millions of Users</h2>
            
            <div class="section">
                <h3>Single Server Setup</h3>
                <div class="key-points">
                    <ul>
                        <li>Web app, database, cache run on single server</li>
                        <li>DNS translates domain to IP address</li>
                        <li>HTTP requests handled by web server</li>
                        <li>Database queries executed and results returned</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3>Database Separation</h3>
                <div class="key-points">
                    <ul>
                        <li>Separate web/mobile traffic from database</li>
                        <li>Independent scaling of web and data tiers</li>
                        <li>Choose between SQL and NoSQL databases</li>
                    </ul>
                </div>
                
                <div class="pros-cons">
                    <div class="pros">
                        <h4>SQL Databases (RDBMS)</h4>
                        <ul>
                            <li>ACID properties</li>
                            <li>SQL queries</li>
                            <li>Mature ecosystem</li>
                            <li>Strong consistency</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>NoSQL Databases</h4>
                        <ul>
                            <li>Low latency</li>
                            <li>Unstructured data</li>
                            <li>Massive scale</li>
                            <li>Rapid development</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Load Balancer</h3>
                <div class="key-points">
                    <ul>
                        <li>Distributes incoming requests across multiple servers</li>
                        <li>Improves availability and fault tolerance</li>
                        <li>Private IPs for server communication</li>
                        <li>Prevents server overload</li>
                    </ul>
                </div>
                
                <div class="highlight">
                    <strong>Key Benefit:</strong> If one server goes offline, load balancer routes traffic to healthy servers
                </div>
            </div>
            
            <div class="section">
                <h3>Database Replication</h3>
                <div class="architecture-pattern">
                    <h4>Master-Slave Architecture</h4>
                    <div class="key-points">
                        <ul>
                            <li>Master database: handles write operations</li>
                            <li>Slave databases: handle read operations</li>
                            <li>Data replicated from master to slaves</li>
                            <li>Better performance for read-heavy applications</li>
                        </ul>
                    </div>
                </div>
                
                <div class="pros-cons">
                    <div class="pros">
                        <h4>Advantages</h4>
                        <ul>
                            <li>Better read performance</li>
                            <li>Reliability and availability</li>
                            <li>Disaster recovery</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>Failure Scenarios</h4>
                        <ul>
                            <li>Slave failure: redirect reads</li>
                            <li>Master failure: promote slave</li>
                            <li>Multiple slave failures: read from master</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Cache Layer</h3>
                <div class="key-points">
                    <ul>
                        <li>Temporary storage for expensive responses</li>
                        <li>Read-through cache pattern</li>
                        <li>Cache-aside pattern</li>
                        <li>Significantly improves performance</li>
                    </ul>
                </div>
                
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Cache Considerations</h4>
                        <p>Expiration policy, consistency, mitigation of failures, eviction policy</p>
                    </div>
                    <div class="metric-card">
                        <h4>When to Use Cache</h4>
                        <p>Read frequently, modified infrequently, not critical data</p>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Content Delivery Network (CDN)</h3>
                <div class="key-points">
                    <ul>
                        <li>Geographically distributed servers</li>
                        <li>Deliver static content (CSS, JS, images)</li>
                        <li>Reduces latency for users</li>
                        <li>Push vs Pull CDN models</li>
                    </ul>
                </div>
                
                <div class="highlight">
                    <strong>CDN Workflow:</strong> User → CDN → Origin Server (if cache miss) → CDN → User
                </div>
            </div>
            
            <div class="section">
                <h3>Stateless Web Tier</h3>
                <div class="key-points">
                    <ul>
                        <li>Move session data out of web tier</li>
                        <li>Store in persistent storage (Redis, database)</li>
                        <li>Enables horizontal scaling</li>
                        <li>Auto-scaling based on traffic</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3>Multi-Data Center Setup</h3>
                <div class="architecture-pattern">
                    <h4>Global Architecture</h4>
                    <div class="key-points">
                        <ul>
                            <li>GeoDNS routes users to closest data center</li>
                            <li>Data synchronization across centers</li>
                            <li>Test and deployment across regions</li>
                            <li>Automatic failover mechanisms</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Message Queue</h3>
                <div class="key-points">
                    <ul>
                        <li>Decouples system components</li>
                        <li>Producers create messages</li>
                        <li>Consumers process messages</li>
                        <li>Enables independent scaling</li>
                    </ul>
                </div>
                
                <div class="highlight">
                    <strong>Benefit:</strong> If consumers are slow, messages queue up. If queue empty, consumers wait.
                </div>
            </div>
            
            <div class="section">
                <h3>Database Scaling</h3>
                <div class="pros-cons">
                    <div class="pros">
                        <h4>Vertical Scaling (Scale Up)</h4>
                        <ul>
                            <li>Add more power to existing machine</li>
                            <li>Simple implementation</li>
                            <li>Good for small datasets</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>Horizontal Scaling (Sharding)</h4>
                        <ul>
                            <li>Add more servers to resource pool</li>
                            <li>Complex but highly scalable</li>
                            <li>Required for massive datasets</li>
                        </ul>
                    </div>
                </div>
                
                <div class="highlight">
                    <strong>Sharding Challenges:</strong> Resharding, celebrity problem, join queries across shards
                </div>
            </div>
        </div>
        
        <div id="chapter2" class="tab-content">
            <h2 class="chapter-title">Chapter 2: Back-of-the-envelope Estimation</h2>
            
            <div class="section">
                <h3>Power of Two</h3>
                <div class="key-points">
                    <ul>
                        <li>2^10 = 1 Thousand (1KB)</li>
                        <li>2^20 = 1 Million (1MB)</li>
                        <li>2^30 = 1 Billion (1GB)</li>
                        <li>2^40 = 1 Trillion (1TB)</li>
                    </ul>
                </div>
                
                <div class="formula">
                    1 Byte = 8 bits | 1 KB = 1,024 Bytes | 1 MB = 1,024 KB
                </div>
            </div>
            
            <div class="section">
                <h3>Latency Numbers</h3>
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Memory Operations</h4>
                        <p>L1 cache: 0.5 ns<br>L2 cache: 7 ns<br>RAM: 100 ns</p>
                    </div>
                    <div class="metric-card">
                        <h4>Network Operations</h4>
                        <p>1 Gbps network: 10,000 ns<br>Inter-continental: 150,000 ns</p>
                    </div>
                    <div class="metric-card">
                        <h4>Storage Operations</h4>
                        <p>SSD read: 150,000 ns<br>Disk seek: 10,000,000 ns</p>
                    </div>
                </div>
                
                <div class="highlight">
                    <strong>Key Insight:</strong> Memory is fast, disk is slow, network calls are expensive
                </div>
            </div>
            
            <div class="section">
                <h3>Availability Numbers</h3>
                <div class="key-points">
                    <ul>
                        <li>99% = 3.65 days downtime/year</li>
                        <li>99.9% = 8.77 hours downtime/year</li>
                        <li>99.99% = 52.6 minutes downtime/year</li>
                        <li>99.999% = 5.26 minutes downtime/year</li>
                    </ul>
                </div>
                
                <div class="formula">
                    Availability = Uptime / (Uptime + Downtime) × 100%
                </div>
            </div>
            
            <div class="section">
                <h3>Estimation Techniques</h3>
                <div class="architecture-pattern">
                    <h4>Step-by-Step Approach</h4>
                    <div class="key-points">
                        <ul>
                            <li>Understand the problem and scope</li>
                            <li>Estimate scale (users, requests, data)</li>
                            <li>Calculate resource requirements</li>
                            <li>Validate assumptions with interviewer</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Example: Twitter QPS Estimation</h3>
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Given</h4>
                        <p>300M users<br>50% daily active<br>Each posts 2 tweets/day<br>10% tweets have media</p>
                    </div>
                    <div class="metric-card">
                        <h4>Calculations</h4>
                        <p>DAU = 300M × 0.5 = 150M<br>QPS = 150M × 2 / 86400 ≈ 3,500<br>Peak QPS = 3,500 × 2 = 7,000</p>
                    </div>
                </div>
                
                <div class="highlight">
                    <strong>Media Storage:</strong> 150M × 2 × 0.1 × 1MB = 30TB/day
                </div>
            </div>
            
            <div class="section">
                <h3>Common Assumptions</h3>
                <div class="key-points">
                    <ul>
                        <li>Read-heavy system: 100:1 read/write ratio</li>
                        <li>Peak QPS = Average QPS × 2</li>
                        <li>80-20 rule: 80% requests from 20% data</li>
                        <li>Character = 1 byte, Integer = 4 bytes</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3>Storage Calculations</h3>
                <div class="architecture-pattern">
                    <h4>Data Size Estimation</h4>
                    <div class="key-points">
                        <ul>
                            <li>Text: Average tweet 140 chars = 140 bytes</li>
                            <li>Images: Average 200KB per image</li>
                            <li>Videos: Average 2MB per video</li>
                            <li>Metadata: User info, timestamps ~100 bytes</li>
                        </ul>
                    </div>
                </div>
                
                <div class="formula">
                    Total Storage = (Data per item × Items per time) × Time period
                </div>
            </div>
            
            <div class="section">
                <h3>Bandwidth Calculations</h3>
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Ingress (Write)</h4>
                        <p>Data coming into system<br>QPS × Average data size<br>Peak traffic considerations</p>
                    </div>
                    <div class="metric-card">
                        <h4>Egress (Read)</h4>
                        <p>Data going out of system<br>Much higher than ingress<br>CDN reduces bandwidth</p>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Memory Calculations</h3>
                <div class="key-points">
                    <ul>
                        <li>Cache 20% of daily requests (80-20 rule)</li>
                        <li>Each cached item with metadata</li>
                        <li>Cache hit ratio considerations</li>
                        <li>Memory hierarchy optimization</li>
                    </ul>
                </div>
                
                <div class="highlight">
                    <strong>Cache Size = Daily requests × 0.2 × Cached item size</strong>
                </div>
            </div>
        </div>
        
        <div id="chapter3" class="tab-content">
            <h2 class="chapter-title">Chapter 3: A Framework for System Design Interviews</h2>
            
            <div class="section">
                <h3>4-Step Process</h3>
                <div class="architecture-pattern">
                    <h4>Systematic Approach</h4>
                    <div class="key-points">
                        <ul>
                            <li>Step 1: Understand the problem and establish scope</li>
                            <li>Step 2: Propose high-level design</li>
                            <li>Step 3: Design deep dive</li>
                            <li>Step 4: Wrap up</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Step 1: Understand the Problem</h3>
                <div class="key-points">
                    <ul>
                        <li>What specific features to build?</li>
                        <li>How many users does the product have?</li>
                        <li>How fast does the company anticipate to scale up?</li>
                        <li>What is the company's technology stack?</li>
                        <li>What existing services can be leveraged?</li>
                    </ul>
                </div>
                
                <div class="highlight">
                    <strong>Key:</strong> Ask clarifying questions - don't assume anything!
                </div>
                
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Functional Requirements</h4>
                        <p>What the system should do<br>Core features and capabilities<br>User interactions</p>
                    </div>
                    <div class="metric-card">
                        <h4>Non-Functional Requirements</h4>
                        <p>How the system should perform<br>Scalability, reliability, consistency<br>Performance metrics</p>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Step 2: Propose High-Level Design</h3>
                <div class="key-points">
                    <ul>
                        <li>Come up with initial blueprint</li>
                        <li>Draw main components on whiteboard</li>
                        <li>Ask for feedback from interviewer</li>
                        <li>Collaborate and iterate on design</li>
                    </ul>
                </div>
                
                <div class="architecture-pattern">
                    <h4>Common Components</h4>
                    <div class="key-points">
                        <ul>
                            <li>Load balancer</li>
                            <li>Web servers</li>
                            <li>Database (SQL/NoSQL)</li>
                            <li>Cache (Redis/Memcached)</li>
                            <li>CDN for static content</li>
                            <li>Message queues</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Back-of-Envelope Calculations</h3>
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Traffic Estimation</h4>
                        <p>Daily/Monthly active users<br>Read vs Write ratio<br>Peak QPS calculations</p>
                    </div>
                    <div class="metric-card">
                        <h4>Storage Estimation</h4>
                        <p>Data size per user/item<br>Growth rate over time<br>5-year storage projection</p>
                    </div>
                    <div class="metric-card">
                        <h4>Bandwidth Estimation</h4>
                        <p>Ingress (incoming data)<br>Egress (outgoing data)<br>CDN requirements</p>
                    </div>
                </div>
                
                <div class="formula">
                    QPS = Daily Active Users × Actions per user / 86400 seconds
                </div>
            </div>
            
            <div class="section">
                <h3>Step 3: Design Deep Dive</h3>
                <div class="key-points">
                    <ul>
                        <li>Agree on overall goals and feature scope</li>
                        <li>Sketch the main use cases</li>
                        <li>Identify and resolve bottlenecks</li>
                        <li>Summarize the design</li>
                    </ul>
                </div>
                
                <div class="architecture-pattern">
                    <h4>Focus Areas Based on Problem</h4>
                    <div class="key-points">
                        <ul>
                            <li>URL shortener: Hash function, base62 encoding</li>
                            <li>Chat system: WebSocket, message ordering</li>
                            <li>News feed: Fanout strategies, timeline generation</li>
                            <li>Search: Indexing, ranking algorithms</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Step 4: Wrap Up</h3>
                <div class="key-points">
                    <ul>
                        <li>Recap the design and key decisions</li>
                        <li>Discuss system bottlenecks and how to address them</li>
                        <li>Summarize how to scale the system</li>
                        <li>Identify potential failure points</li>
                    </ul>
                </div>
                
                <div class="pros-cons">
                    <div class="pros">
                        <h4>Additional Talking Points</h4>
                        <ul>
                            <li>Monitoring and logging</li>
                            <li>Security considerations</li>
                            <li>Deployment strategies</li>
                            <li>A/B testing framework</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>Avoid These Mistakes</h4>
                        <ul>
                            <li>Over-engineering the solution</li>
                            <li>Ignoring non-functional requirements</li>
                            <li>Not explaining trade-offs</li>
                            <li>Being too quiet during design</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Time Management</h3>
                <div class="metrics">
                    <div class="metric-card">
                        <h4>45-60 Minute Interview</h4>
                        <p>Step 1: 3-10 minutes<br>Step 2: 10-15 minutes<br>Step 3: 10-25 minutes<br>Step 4: 3-5 minutes</p>
                    </div>
                </div>
                
                <div class="highlight">
                    <strong>Pro Tip:</strong> Always validate your understanding with the interviewer before proceeding
                </div>
            </div>
            
            <div class="section">
                <h3>Communication Tips</h3>
                <div class="key-points">
                    <ul>
                        <li>Think out loud - explain your thought process</li>
                        <li>Ask clarifying questions throughout</li>
                        <li>Explain trade-offs for different approaches</li>
                        <li>Don't be afraid to admit when you don't know something</li>
                        <li>Draw diagrams to illustrate your points</li>
                        <li>Be open to feedback and suggestions</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div id="chapter4" class="tab-content">
            <h2 class="chapter-title">Chapter 4: Design a Rate Limiter</h2>
            
            <div class="section">
                <h3>What is Rate Limiting?</h3>
                <div class="key-points">
                    <ul>
                        <li>Controls rate of traffic sent by client or service</li>
                        <li>Prevents resource starvation caused by DoS attacks</li>
                        <li>Reduces cost by limiting excess requests</li>
                        <li>Prevents servers from being overloaded</li>
                    </ul>
                </div>
                
                <div class="highlight">
                    <strong>HTTP 429:</strong> "Too Many Requests" response when rate limit exceeded
                </div>
            </div>
            
            <div class="section">
                <h3>Where to Put Rate Limiter?</h3>
                <div class="pros-cons">
                    <div class="pros">
                        <h4>Client-Side</h4>
                        <ul>
                            <li>Easy to implement</li>
                            <li>Can be unreliable (client controlled)</li>
                            <li>Not recommended for security</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>Server-Side</h4>
                        <ul>
                            <li>More reliable and secure</li>
                            <li>Can be implemented as middleware</li>
                            <li>API gateway is common choice</li>
                        </ul>
                    </div>
                </div>
                
                <div class="architecture-pattern">
                    <h4>API Gateway Approach</h4>
                    <div class="key-points">
                        <ul>
                            <li>Fully managed service (AWS API Gateway, Azure API Management)</li>
                            <li>Supports rate limiting, SSL termination, authentication</li>
                            <li>Centralized place for rate limiting policies</li>
                            <li>Easy to configure and maintain</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Rate Limiting Algorithms</h3>
                
                <div class="architecture-pattern">
                    <h4>1. Token Bucket Algorithm</h4>
                    <div class="key-points">
                        <ul>
                            <li>Bucket has predefined capacity</li>
                            <li>Tokens added at preset rates</li>
                            <li>Each request consumes one token</li>
                            <li>Request dropped if no token available</li>
                        </ul>
                    </div>
                    
                    <div class="pros-cons">
                        <div class="pros">
                            <h4>Pros</h4>
                            <ul>
                                <li>Easy to implement</li>
                                <li>Memory efficient</li>
                                <li>Allows burst of traffic</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>Cons</h4>
                            <ul>
                                <li>Two parameters to tune</li>
                                <li>Challenging to tune properly</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="architecture-pattern">
                    <h4>2. Leaking Bucket Algorithm</h4>
                    <div class="key-points">
                        <ul>
                            <li>Requests processed at fixed rate</li>
                            <li>FIFO queue for incoming requests</li>
                            <li>Requests dropped when queue is full</li>
                            <li>Smooths out bursts of requests</li>
                        </ul>
                    </div>
                    
                    <div class="pros-cons">
                        <div class="pros">
                            <h4>Pros</h4>
                            <ul>
                                <li>Memory efficient</li>
                                <li>Stable outflow rate</li>
                                <li>Suitable when stable rate needed</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>Cons</h4>
                            <ul>
                                <li>Burst of traffic fills queue</li>
                                <li>Recent requests may be dropped</li>
                                <li>Two parameters to tune</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="architecture-pattern">
                    <h4>3. Fixed Window Counter</h4>
                    <div class="key-points">
                        <ul>
                            <li>Timeline divided into fixed-size windows</li>
                            <li>Counter for each window</li>
                            <li>Requests dropped when counter reaches limit</li>
                            <li>Counter resets at start of new window</li>
                        </ul>
                    </div>
                    
                    <div class="highlight">
                        <strong>Edge Case:</strong> Traffic spike at window edges can exceed limit
                    </div>
                </div>
                
                <div class="architecture-pattern">
                    <h4>4. Sliding Window Log</h4>
                    <div class="key-points">
                        <ul>
                            <li>Keep track of request timestamps</li>
                            <li>Remove outdated timestamps</li>
                            <li>Add timestamp for new request</li>
                            <li>Very accurate but memory intensive</li>
                        </ul>
                    </div>
                </div>
                
                <div class="architecture-pattern">
                    <h4>5. Sliding Window Counter</h4>
                    <div class="key-points">
                        <li>Hybrid approach combining fixed window counter and sliding window log</li>
                        <li>Approximates sliding window with less memory</li>
                        <li>Uses weighted calculation from previous window</li>
                        <li>Good balance between accuracy and efficiency</li>
                    </ul>
                    </div>
                    <div class="formula">
                        Requests = Current Window + (Previous Window × Overlap Percentage)
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>High-Level Architecture</h3>
                <div class="key-points">
                    <ul>
                        <li>Rate limiter middleware intercepts requests</li>
                        <li>Rules stored in cache (Redis) for fast access</li>
                        <li>Counters stored in Redis with TTL</li>
                        <li>Rules retrieved from database on cache miss</li>
                    </ul>
                </div>
                
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Rate Limiter Rules</h4>
                        <p>User ID, IP address, API endpoint<br>Rate limit per minute/hour/day<br>Marketing campaigns, user tiers</p>
                    </div>
                    <div class="metric-card">
                        <h4>Redis Commands</h4>
                        <p>INCR: Increment counter<br>EXPIRE: Set TTL<br>Pipeline for atomic operations</p>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Detailed Design</h3>
                <div class="architecture-pattern">
                    <h4>Rate Limiter Rules</h4>
                    <div class="key-points">
                        <ul>
                            <li>Lyft: 5 requests per minute for marketing SMS</li>
                            <li>Google Docs: 300 requests per minute per user</li>
                            <li>Usually stored in configuration files</li>
                            <li>Loaded into cache for performance</li>
                        </ul>
                    </div>
                </div>
                
                <div class="architecture-pattern">
                    <h4>Exceeding Rate Limit</h4>
                    <div class="key-points">
                        <ul>
                            <li>Return HTTP 429 Too Many Requests</li>
                            <li>Drop request or forward to message queue</li>
                            <li>Include rate limit headers in response</li>
                        </ul>
                    </div>
                </div>
                
                <div class="highlight">
                    <strong>Rate Limit Headers:</strong><br>
                    X-Ratelimit-Remaining: Number of requests left<br>
                    X-Ratelimit-Limit: How many calls allowed<br>
                    X-Ratelimit-Retry-After: Seconds to wait
                </div>
            </div>
            
            <div class="section">
                <h3>Distributed Rate Limiter</h3>
                <div class="key-points">
                    <ul>
                        <li>Multiple rate limiter servers</li>
                        <li>Shared data store (Redis cluster)</li>
                        <li>Race conditions with concurrent requests</li>
                        <li>Synchronization performance cost</li>
                    </ul>
                </div>
                
                <div class="pros-cons">
                    <div class="pros">
                        <h4>Solutions for Race Conditions</h4>
                        <ul>
                            <li>Lua scripts for atomic operations</li>
                            <li>Sorted sets in Redis</li>
                            <li>Eventual consistency model</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>Performance Optimization</h4>
                        <ul>
                            <li>Use eventual consistency</li>
                            <li>Local rate limiter with sync</li>
                            <li>Sticky sessions to reduce sync</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Monitoring</h3>
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Key Metrics</h4>
                        <p>Rate limiter effectiveness<br>Rate limiter algorithm performance<br>Rate limiter rules effectiveness</p>
                    </div>
                    <div class="metric-card">
                        <h4>Alerts</h4>
                        <p>Sudden increase in dropped requests<br>Rate limiter servers going down<br>Cache server failures</p>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Design Summary</h3>
                <div class="key-points">
                    <ul>
                        <li>Algorithms: Token bucket for general purpose</li>
                        <li>Architecture: Rate limiter middleware with Redis</li>
                        <li>Distributed: Handle race conditions and sync</li>
                        <li>Monitoring: Track metrics and set up alerts</li>
                        <li>Hard vs Soft rate limiting based on use case</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div id="chapter5" class="tab-content">
            <h2 class="chapter-title">Chapter 5: Design Consistent Hashing</h2>
            
            <div class="section">
                <h3>The Rehashing Problem</h3>
                <div class="key-points">
                    <ul>
                        <li>Traditional hash function: hash(key) % N</li>
                        <li>When server added/removed, most keys rehashed</li>
                        <li>Causes massive cache misses</li>
                        <li>Can bring down the system</li>
                    </ul>
                </div>
                
                <div class="formula">
                    Traditional: serverIndex = hash(key) % N
                </div>
                
                <div class="highlight">
                    <strong>Problem:</strong> Adding 1 server changes 80% of key mappings in a 4-server system
                </div>
            </div>
            
            <div class="section">
                <h3>Consistent Hashing</h3>
                <div class="key-points">
                    <ul>
                        <li>Hash servers and keys onto a ring</li>
                        <li>Key goes to first server clockwise</li>
                        <li>Adding/removing server affects only immediate neighbors</li>
                        <li>Minimizes key redistribution</li>
                    </ul>
                </div>
                
                <div class="architecture-pattern">
                    <h4>Hash Ring Process</h4>
                    <div class="key-points">
                        <ul>
                            <li>Map servers to positions on ring using hash function</li>
                            <li>Map keys to positions on ring using same hash function</li>
                            <li>Key is stored on first server encountered clockwise</li>
                            <li>Wrap around: if no server clockwise, use first server</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Adding/Removing Servers</h3>
                <div class="pros-cons">
                    <div class="pros">
                        <h4>Adding Server</h4>
                        <ul>
                            <li>Only keys between new server and previous server affected</li>
                            <li>Minimal key redistribution</li>
                            <li>Other keys remain unchanged</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>Removing Server</h4>
                        <ul>
                            <li>Keys go to next server clockwise</li>
                            <li>Only affected keys need redistribution</li>
                            <li>Maintains system stability</li>
                        </ul>
                    </div>
                </div>
                
                <div class="highlight">
                    <strong>Benefit:</strong> Only k/n keys need to be redistributed (k = keys, n = servers)
                </div>
            </div>
            
            <div class="section">
                <h3>Two Problems with Basic Approach</h3>
                <div class="architecture-pattern">
                    <h4>1. Impossible to Keep Same Size Partitions</h4>
                    <div class="key-points">
                        <ul>
                            <li>Servers may not be evenly distributed on ring</li>
                            <li>Some servers get more data than others</li>
                            <li>Uneven load distribution</li>
                            <li>Hot spots can occur</li>
                        </ul>
                    </div>
                </div>
                
                <div class="architecture-pattern">
                    <h4>2. Non-uniform Key Distribution</h4>
                    <div class="key-points">
                        <ul>
                            <li>Keys may not be evenly distributed</li>
                            <li>Some partitions may be empty</li>
                            <li>Others may be overloaded</li>
                            <li>Affects system performance</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Virtual Nodes Solution</h3>
                <div class="key-points">
                    <ul>
                        <li>Each server represented by multiple virtual nodes</li>
                        <li>Virtual nodes distributed around the ring</li>
                        <li>Better load distribution</li>
                        <li>Easier to handle server failures</li>
                    </ul>
                </div>
                
                <div class="formula">
                    Virtual Node = hash(server_name + node_number)
                </div>
                
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Virtual Node Benefits</h4>
                        <p>Better load distribution<br>Easier partition management<br>Faster replication/recovery</p>
                    </div>
                    <div class="metric-card">
                        <h4>Trade-offs</h4>
                        <p>More virtual nodes = better distribution<br>But increased memory overhead<br>Need to balance the two</p>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Find Affected Keys</h3>
                <div class="architecture-pattern">
                    <h4>Adding Server</h4>
                    <div class="key-points">
                        <ul>
                            <li>Keys between new server and predecessor affected</li>
                            <li>These keys move to new server</li>
                            <li>Reduces load on other servers</li>
                        </ul>
                    </div>
                </div>
                
                <div class="architecture-pattern">
                    <h4>Removing Server</h4>
                    <div class="key-points">
                        <ul>
                            <li>Keys on removed server redistributed</li>
                            <li>Go to successor server on ring</li>
                            <li>Increases load on successor</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Implementation Details</h3>
                <div class="key-points">
                    <ul>
                        <li>Use sorted map/tree for efficient lookup</li>
                        <li>Binary search to find server for key</li>
                        <li>Handle wrap-around case properly</li>
                        <li>Maintain virtual node to server mapping</li>
                    </ul>
                </div>
                
                <div class="highlight">
                    <strong>Time Complexity:</strong> O(log N) for key lookup with N virtual nodes
                </div>
            </div>
            
            <div class="section">
                <h3>Benefits of Consistent Hashing</h3>
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Minimal Key Movement</h4>
                        <p>Only k/n keys redistributed<br>Prevents cascade failures<br>Maintains system stability</p>
                    </div>
                    <div class="metric-card">
                        <h4>Load Distribution</h4>
                        <p>Virtual nodes ensure fairness<br>Configurable granularity<br>Better resource utilization</p>
                    </div>
                    <div class="metric-card">
                        <h4>Fault Tolerance</h4>
                        <p>Graceful handling of failures<br>Automatic redistribution<br>No single point of failure</p>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Real-World Usage</h3>
                <div class="architecture-pattern">
                    <h4>Systems Using Consistent Hashing</h4>
                    <div class="key-points">
                        <ul>
                            <li>Amazon DynamoDB: Partition data across nodes</li>
                            <li>Apache Cassandra: Data distribution and replication</li>
                            <li>Discord: Distribute users across shards</li>
                            <li>Akamai CDN: Route requests to servers</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>Design Summary</h3>
                <div class="key-points">
                    <ul>
                        <li>Consistent hashing maps keys and servers to ring</li>
                        <li>Virtual nodes solve distribution problems</li>
                        <li>Minimal key redistribution when scaling</li>
                        <li>Essential for distributed systems</li>
                        <li>Used by major tech companies at scale</li>
                    </ul>
                </div>
                
                <div class="highlight">
                    <strong>Key Insight:</strong> Consistent hashing is foundation for building scalable distributed systems
                </div>
            </div>
        </div>
        <div id="chapter6" class="tab-content">
    <h2 class="chapter-title">Chapter 6: Design a Key-Value Store</h2>
    
    <div class="section">
        <h3>Problem Understanding</h3>
        <div class="key-points">
            <ul>
                <li>Key-value pair is unique identifier (key) + associated value</li>
                <li>Examples: Amazon DynamoDB, Memcached, Redis</li>
                <li>Operations: put(key, value) and get(key)</li>
                <li>Requirements: Large data size, high availability, automatic scaling</li>
            </ul>
        </div>
    </div>
    
    <div class="section">
        <h3>Single Server Key-Value Store</h3>
        <div class="key-points">
            <ul>
                <li>Hash table in memory for fast access</li>
                <li>Data compression to fit more data</li>
                <li>Store frequently used data in memory, rest on disk</li>
                <li>Limited by server capacity</li>
            </ul>
        </div>
    </div>
    
    <div class="section">
        <h3>Distributed Key-Value Store</h3>
        <div class="architecture-pattern">
            <h4>CAP Theorem</h4>
            <div class="key-points">
                <ul>
                    <li><strong>Consistency:</strong> All nodes see same data simultaneously</li>
                    <li><strong>Availability:</strong> System remains operational</li>
                    <li><strong>Partition tolerance:</strong> System continues despite network failures</li>
                    <li><strong>Reality:</strong> Can only guarantee 2 out of 3</li>
                </ul>
            </div>
        </div>
        
        <div class="pros-cons">
            <div class="pros">
                <h4>CP Systems</h4>
                <ul>
                    <li>Consistency + Partition tolerance</li>
                    <li>Block writes when network partitioned</li>
                    <li>Example: Banking systems</li>
                </ul>
            </div>
            <div class="cons">
                <h4>AP Systems</h4>
                <ul>
                    <li>Availability + Partition tolerance</li>
                    <li>Accept writes, sync when partition heals</li>
                    <li>Example: Social media feeds</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>System Components</h3>
        
        <div class="architecture-pattern">
            <h4>Data Partition</h4>
            <div class="key-points">
                <ul>
                    <li>Use consistent hashing for even distribution</li>
                    <li>Virtual nodes solve hot spot problem</li>
                    <li>Automatic scaling with adding/removing nodes</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Data Replication</h4>
            <div class="key-points">
                <ul>
                    <li>Replicate data to N nodes for reliability</li>
                    <li>Store replicas on different nodes clockwise on ring</li>
                    <li>Nodes in different data centers for geo-diversity</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Consistency Models</h3>
        
        <div class="metrics">
            <div class="metric-card">
                <h4>Strong Consistency</h4>
                <p>All reads get most recent write<br>High latency<br>Banking, financial systems</p>
            </div>
            <div class="metric-card">
                <h4>Weak Consistency</h4>
                <p>Reads may not get latest write<br>Low latency<br>Real-time gaming, live streaming</p>
            </div>
            <div class="metric-card">
                <h4>Eventual Consistency</h4>
                <p>System becomes consistent over time<br>Balance of performance and consistency<br>Social media, email</p>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Quorum Consensus</h3>
        <div class="formula">
            N = Number of replicas<br>
            W = Write quorum size<br>
            R = Read quorum size
        </div>
        
        <div class="key-points">
            <ul>
                <li>Write succeeds if W nodes acknowledge</li>
                <li>Read succeeds if R nodes respond</li>
                <li>W + R > N ensures strong consistency</li>
                <li>Common configurations: R=1, W=N (fast reads), R=N, W=1 (fast writes)</li>
            </ul>
        </div>
    </div>
    
    <div class="section">
        <h3>Consistency Models in Practice</h3>
        
        <div class="architecture-pattern">
            <h4>Vector Clocks</h4>
            <div class="key-points">
                <ul>
                    <li>Track causality between events</li>
                    <li>Each node has counter for each server</li>
                    <li>Detect concurrent writes and conflicts</li>
                    <li>Client resolves conflicts on read</li>
                </ul>
            </div>
        </div>
        
        <div class="highlight">
            <strong>Conflict Resolution:</strong> Last write wins, application-specific logic, or vector clocks
        </div>
    </div>
    
    <div class="section">
        <h3>Failure Handling</h3>
        
        <div class="pros-cons">
            <div class="pros">
                <h4>Failure Detection</h4>
                <ul>
                    <li>Gossip protocol for distributed failure detection</li>
                    <li>Each node maintains member list</li>
                    <li>Periodically send heartbeats</li>
                </ul>
            </div>
            <div class="cons">
                <h4>Temporary Failures</h4>
                <ul>
                    <li>Sloppy quorum: first W healthy nodes</li>
                    <li>Hinted handoff: temporary storage</li>
                    <li>Anti-entropy: sync replicas</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>System Architecture Recap</h3>
        <div class="key-points">
            <ul>
                <li>Clients communicate through API (get, put)</li>
                <li>Mediator/coordinator handles requests</li>
                <li>Consistent hashing for data distribution</li>
                <li>Replication for reliability and availability</li>
                <li>Consistency models based on use case</li>
                <li>Gossip protocol for failure detection</li>
            </ul>
        </div>
    </div>
</div>

<div id="chapter7" class="tab-content">
    <h2 class="chapter-title">Chapter 7: Design a Unique ID Generator</h2>
    
    <div class="section">
        <h3>Problem Requirements</h3>
        <div class="key-points">
            <ul>
                <li>IDs must be unique across distributed system</li>
                <li>IDs are numerical and 64-bit</li>
                <li>IDs ordered by date (sortable)</li>
                <li>Generate 10,000 IDs per second</li>
            </ul>
        </div>
    </div>
    
    <div class="section">
        <h3>Approach 1: Multi-Master Replication</h3>
        <div class="key-points">
            <ul>
                <li>Use database auto_increment with step size</li>
                <li>Server 1: 1, 3, 5, 7... (step=2, start=1)</li>
                <li>Server 2: 2, 4, 6, 8... (step=2, start=2)</li>
            </ul>
        </div>
        
        <div class="pros-cons">
            <div class="pros">
                <h4>Pros</h4>
                <ul>
                    <li>Easy to implement</li>
                    <li>Works for small scale</li>
                    <li>No coordination needed</li>
                </ul>
            </div>
            <div class="cons">
                <h4>Cons</h4>
                <ul>
                    <li>Hard to scale with multiple data centers</li>
                    <li>IDs don't increase with time across servers</li>
                    <li>Database single point of failure</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Approach 2: UUID (Universally Unique Identifier)</h3>
        <div class="key-points">
            <ul>
                <li>128-bit number used to identify information</li>
                <li>Very low probability of collision</li>
                <li>Can be generated independently on each server</li>
                <li>Example: 09c93e62-50b4-468d-bf8a-c07e1040bfb2</li>
            </ul>
        </div>
        
        <div class="pros-cons">
            <div class="pros">
                <h4>Pros</h4>
                <ul>
                    <li>Simple, no coordination needed</li>
                    <li>Easy to scale (each server generates)</li>
                    <li>No single point of failure</li>
                </ul>
            </div>
            <div class="cons">
                <h4>Cons</h4>
                <ul>
                    <li>IDs are 128 bits (requirement is 64-bit)</li>
                    <li>Non-numeric</li>
                    <li>Not sortable by time</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Approach 3: Ticket Server</h3>
        <div class="key-points">
            <ul>
                <li>Centralized auto_increment server</li>
                <li>Single point to generate unique IDs</li>
                <li>Lightweight server with database</li>
            </ul>
        </div>
        
        <div class="pros-cons">
            <div class="pros">
                <h4>Pros</h4>
                <ul>
                    <li>Numeric IDs</li>
                    <li>Easy to implement</li>
                    <li>Works for small to medium scale</li>
                </ul>
            </div>
            <div class="cons">
                <h4>Cons</h4>
                <ul>
                    <li>Single point of failure</li>
                    <li>Becomes bottleneck at scale</li>
                    <li>Network latency affects performance</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Approach 4: Twitter Snowflake</h3>
        <div class="architecture-pattern">
            <h4>64-bit ID Structure</h4>
            <div class="formula">
                1 bit (sign) + 41 bits (timestamp) + 5 bits (datacenter ID) + 5 bits (machine ID) + 12 bits (sequence)
            </div>
            <div class="key-points">
                <ul>
                    <li><strong>Sign bit:</strong> Always 0 (reserved for future use)</li>
                    <li><strong>Timestamp:</strong> Milliseconds since epoch (41 bits = 69 years)</li>
                    <li><strong>Datacenter ID:</strong> 5 bits = 32 datacenters</li>
                    <li><strong>Machine ID:</strong> 5 bits = 32 machines per datacenter</li>
                    <li><strong>Sequence:</strong> 12 bits = 4096 IDs per millisecond per machine</li>
                </ul>
            </div>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <h4>Capacity</h4>
                <p>1024 machines total<br>4.096M IDs per second per machine<br>Supports high throughput</p>
            </div>
            <div class="metric-card">
                <h4>Time Ordering</h4>
                <p>IDs sortable by timestamp<br>Can extract creation time<br>Helps with debugging</p>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Snowflake Deep Dive</h3>
        
        <div class="architecture-pattern">
            <h4>Algorithm</h4>
            <div class="key-points">
                <ul>
                    <li>Get current timestamp in milliseconds</li>
                    <li>If same timestamp as previous, increment sequence</li>
                    <li>If different timestamp, reset sequence to 0</li>
                    <li>If sequence overflows, wait for next millisecond</li>
                </ul>
            </div>
        </div>
        
        <div class="highlight">
            <strong>Clock Synchronization:</strong> Critical issue - NTP drift can cause duplicate IDs
        </div>
    </div>
    
    <div class="section">
        <h3>Alternative Approaches</h3>
        
        <div class="architecture-pattern">
            <h4>Instagram's Solution</h4>
            <div class="key-points">
                <ul>
                    <li>41 bits timestamp + 13 bits shard ID + 10 bits auto-increment</li>
                    <li>Uses PostgreSQL with custom sequence</li>
                    <li>Each shard generates IDs independently</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>MongoDB ObjectID</h4>
            <div class="key-points">
                <ul>
                    <li>96-bit identifier</li>
                    <li>Timestamp + machine ID + process ID + counter</li>
                    <li>Naturally ordered by creation time</li>
            </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Design Summary</h3>
        <div class="key-points">
            <ul>
                <li>Snowflake approach best for distributed systems</li>
                <li>64-bit numeric IDs that are time-ordered</li>
                <li>No coordination between servers needed</li>
                <li>Can generate 4M+ IDs per second per machine</li>
                <li>Handle clock synchronization carefully</li>
            </ul>
        </div>
        
        <div class="highlight">
            <strong>Key Decision:</strong> Trade-off between simplicity (UUID) vs requirements (Snowflake)
        </div>
    </div>
</div>

<div id="chapter8" class="tab-content">
    <h2 class="chapter-title">Chapter 8: Design a URL Shortener</h2>
    
    <div class="section">
        <h3>Problem Requirements</h3>
        <div class="key-points">
            <ul>
                <li>URL shortening: long URL → short URL</li>
                <li>URL redirecting: short URL → original URL</li>
                <li>100M URLs generated per day</li>
                <li>Read/Write ratio: 100:1</li>
                <li>URL shortener service should be highly available</li>
            </ul>
        </div>
        
        <div class="formula">
            QPS = 100M / (24 * 3600) ≈ 1160<br>
            Read QPS = 1160 * 100 = 116,000
        </div>
    </div>
    
    <div class="section">
        <h3>Capacity Estimation</h3>
        <div class="metrics">
            <div class="metric-card">
                <h4>Storage</h4>
                <p>100M URLs/day * 365 * 5 years = 182.5B URLs<br>Average URL length: 100 chars<br>Storage: 182.5B * 100 = 18.25TB</p>
            </div>
            <div class="metric-card">
                <h4>Bandwidth</h4>
                <p>Write: 1160 QPS * 100 bytes = 116KB/s<br>Read: 116K QPS * 100 bytes = 11.6MB/s</p>
            </div>
            <div class="metric-card">
                <h4>Cache</h4>
                <p>80-20 rule: cache 20% of daily reads<br>116K * 3600 * 24 * 0.2 * 100 bytes ≈ 200GB</p>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>API Design</h3>
        <div class="key-points">
            <ul>
                <li><strong>POST /api/v1/data/shorten</strong></li>
                <li>Request: {longUrl: "https://www.example.com"}</li>
                <li>Response: {shortUrl: "https://tinyurl.com/y7keocoj"}</li>
            </ul>
        </div>
        
        <div class="key-points">
            <ul>
                <li><strong>GET /api/v1/shortUrl</strong></li>
                <li>Response: HTTP 301 redirect to longUrl</li>
                <li>301 (permanent) vs 302 (temporary) redirect</li>
            </ul>
        </div>
    </div>
    
    <div class="section">
        <h3>URL Encoding Approaches</h3>
        
        <div class="architecture-pattern">
            <h4>Approach 1: Hash + Collision Resolution</h4>
            <div class="key-points">
                <ul>
                    <li>Use hash functions: CRC32, MD5, SHA-1</li>
                    <li>Take first 7 characters of hash</li>
                    <li>Handle hash collisions by appending predefined string</li>
                    <li>Query database to check if hash exists</li>
                </ul>
            </div>
            
            <div class="pros-cons">
                <div class="pros">
                    <h4>Pros</h4>
                    <ul>
                        <li>Straightforward implementation</li>
                        <li>No need for unique ID generator</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>Cons</h4>
                    <ul>
                        <li>Expensive database queries for collision detection</li>
                        <li>Bloom filters can help but add complexity</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Approach 2: Base62 Conversion</h4>
            <div class="key-points">
                <ul>
                    <li>Generate unique ID using methods from Chapter 7</li>
                    <li>Convert ID to base62 string</li>
                    <li>Base62: [0-9, a-z, A-Z] = 62 characters</li>
                    <li>7 characters = 62^7 ≈ 3.5 trillion URLs</li>
                </ul>
            </div>
            
            <div class="formula">
                ID = 11157 → Base62 = "2TX"<br>
                62^7 = 3,521,614,606,208 possible URLs
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>High-Level Design</h3>
        <div class="architecture-pattern">
            <h4>System Components</h4>
            <div class="key-points">
                <ul>
                    <li><strong>Load balancer:</strong> Distribute traffic</li>
                    <li><strong>Web servers:</strong> Handle HTTP requests</li>
                    <li><strong>Database:</strong> Store URL mappings</li>
                    <li><strong>Cache:</strong> Store frequently accessed URLs</li>
                </ul>
            </div>
        </div>
        
        <div class="pros-cons">
            <div class="pros">
                <h4>URL Shortening Flow</h4>
                <ul>
                    <li>User enters long URL</li>
                    <li>System generates unique ID</li>
                    <li>Convert ID to short URL using base62</li>
                    <li>Save mapping to database</li>
                </ul>
            </div>
            <div class="cons">
                <h4>URL Redirecting Flow</h4>
                <ul>
                    <li>User clicks short URL</li>
                    <li>Check cache first</li>
                    <li>If cache miss, query database</li>
                    <li>Return long URL and cache result</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Deep Dive</h3>
        
        <div class="architecture-pattern">
            <h4>Database Schema</h4>
            <div class="key-points">
                <ul>
                    <li><strong>id:</strong> Primary key, auto-increment</li>
                    <li><strong>shortURL:</strong> Base62 converted ID</li>
                    <li><strong>longURL:</strong> Original URL</li>
                    <li><strong>createdAt:</strong> Timestamp</li>
                </ul>
            </div>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <h4>SQL vs NoSQL</h4>
                <p>Relational data (URL mapping)<br>No complex queries needed<br>Both SQL and NoSQL work<br>NoSQL chosen for scale</p>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Cache Strategy</h3>
        <div class="key-points">
            <ul>
                <li>Cache popular URLs using 80-20 rule</li>
                <li>LRU (Least Recently Used) eviction policy</li>
                <li>Multiple cache levels: browser, CDN, server</li>
                <li>Cache short URL → long URL mappings</li>
            </ul>
        </div>
    </div>
    
    <div class="section">
        <h3>Scale the System</h3>
        
        <div class="architecture-pattern">
            <h4>Database Scaling</h4>
            <div class="key-points">
                <ul>
                    <li>Vertical scaling first</li>
                    <li>Horizontal scaling with sharding</li>
                    <li>Replicas for read-heavy workload</li>
                    <li>Consistent hashing for even distribution</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Additional Optimizations</h4>
            <div class="key-points">
                <ul>
                    <li><strong>Analytics:</strong> Track click events, popular links</li>
                    <li><strong>Availability:</strong> Multiple data centers</li>
                    <li><strong>Consistency:</strong> Eventual consistency acceptable</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Additional Features</h3>
        <div class="metrics">
            <div class="metric-card">
                <h4>Custom URLs</h4>
                <p>Allow users to provide custom aliases<br>Check availability before creation<br>Premium feature</p>
            </div>
            <div class="metric-card">
                <h4>Analytics</h4>
                <p>Track clicks, referrers, locations<br>Popular links dashboard<br>A/B testing support</p>
            </div>
            <div class="metric-card">
                <h4>Security</h4>
                <p>Rate limiting per user/IP<br>Malicious URL detection<br>HTTPS enforcement</p>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Design Summary</h3>
        <div class="key-points">
            <ul>
                <li>Base62 encoding with unique ID generation</li>
                <li>Cache layer for read-heavy traffic</li>
                <li>Database sharding for horizontal scaling</li>
                <li>301 vs 302 redirect based on use case</li>
                <li>Analytics and rate limiting for production</li>
            </ul>
        </div>
    </div>
</div>
<div id="chapter9" class="tab-content">
    <h2 class="chapter-title">Chapter 9: Design a Web Crawler</h2>
    
    <div class="section">
        <h3>What is a Web Crawler?</h3>
        <div class="key-points">
            <ul>
                <li>Systematically browses the web to collect information</li>
                <li>Used by search engines to index web pages</li>
                <li>Also called spider, robot, bot, or web scraper</li>
                <li>Starts with seed URLs and follows links recursively</li>
            </ul>
        </div>
        
        <div class="highlight">
            <strong>Scale:</strong> Google processes billions of pages daily
        </div>
    </div>
    
    <div class="section">
        <h3>Step 1: Understand the Problem</h3>
        <div class="key-points">
            <ul>
                <li>Scale: 1 billion web pages per month</li>
                <li>Content types: HTML pages only initially</li>
                <li>Storage duration: 5 years</li>
                <li>Duplicate content handling required</li>
            </ul>
        </div>
        
        <div class="formula">
            QPS = 1 billion pages / (30 days × 24 hours × 3600 seconds) ≈ 400 pages/second
        </div>
        
        <div class="highlight">
            Peak QPS = 2 × 400 = 800 pages/second
        </div>
    </div>
    
    <div class="section">
        <h3>Step 2: High-Level Design</h3>
        <div class="architecture-pattern">
            <h4>Basic Crawler Workflow</h4>
            <div class="key-points">
                <ul>
                    <li>Seed URLs → URL Frontier (queue)</li>
                    <li>HTML Downloader fetches pages</li>
                    <li>Content Parser extracts links</li>
                    <li>URL Filter removes duplicates/unwanted URLs</li>
                    <li>URL Seen? checks if already processed</li>
                    <li>URL Storage stores processed URLs</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 3: Design Deep Dive</h3>
        
        <div class="architecture-pattern">
            <h4>DFS vs BFS</h4>
            <div class="pros-cons">
                <div class="pros">
                    <h4>BFS (Preferred)</h4>
                    <ul>
                        <li>Standard for web crawlers</li>
                        <li>FIFO queue implementation</li>
                        <li>Two problems: don't respect robots.txt, don't prioritize</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>DFS (Not Suitable)</h4>
                    <ul>
                        <li>Can go very deep into single path</li>
                        <li>Not suitable for web crawling</li>
                        <li>Poor coverage of web</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>URL Frontier</h4>
            <div class="key-points">
                <ul>
                    <li>Politeness: Avoid overloading servers</li>
                    <li>Priority: Crawl important pages first</li>
                    <li>Freshness: Recrawl based on update frequency</li>
                </ul>
            </div>
            
            <div class="metrics">
                <div class="metric-card">
                    <h4>Politeness Implementation</h4>
                    <p>Download delay per hostname<br>Mapping table: hostname → queue<br>Queue router and worker threads</p>
                </div>
                <div class="metric-card">
                    <h4>Priority Implementation</h4>
                    <p>Priority queues (high/medium/low)<br>Queue selector with bias<br>Page rank or traffic-based prioritization</p>
                </div>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>HTML Downloader</h4>
            <div class="key-points">
                <ul>
                    <li>Robots.txt compliance</li>
                    <li>Performance optimization (cache DNS, connection pooling)</li>
                    <li>Distributed downloading</li>
                    <li>Error handling and retry logic</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Robustness</h4>
            <div class="key-points">
                <ul>
                    <li>Consistent hashing for load distribution</li>
                    <li>Save crawl states and data</li>
                    <li>Exception handling</li>
                    <li>Data validation</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Extensibility</h4>
            <div class="key-points">
                <ul>
                    <li>PNG downloader for images</li>
                    <li>Web monitor for copyright detection</li>
                    <li>Plugin architecture</li>
            </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Detect and Avoid Problematic Content</h4>
            <div class="key-points">
                <ul>
                    <li>Redundant content: Hash or checksum comparison</li>
                    <li>Spider traps: Set max URL length, blacklist</li>
                    <li>Data noise: Exclude ads, spam, anti-patterns</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 4: Wrap Up</h3>
        <div class="key-points">
            <ul>
                <li>Server-side rendering for dynamic content</li>
                <li>Filter unwanted pages (spam, errors)</li>
                <li>Database replication and sharding</li>
                <li>Horizontal scaling</li>
                <li>Availability, consistency, reliability</li>
                <li>Analytics and monitoring</li>
            </ul>
        </div>
    </div>
</div>

<div id="chapter10" class="tab-content">
    <h2 class="chapter-title">Chapter 10: Design a Notification System</h2>
    
    <div class="section">
        <h3>Types of Notifications</h3>
        <div class="key-points">
            <ul>
                <li>iOS push notification</li>
                <li>Android push notification</li>
                <li>SMS message</li>
                <li>Email</li>
            </ul>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 1: Understand the Problem</h3>
        <div class="key-points">
            <ul>
                <li>Push notification, SMS, email support</li>
                <li>Soft real-time (delay acceptable)</li>
                <li>iOS, Android, laptop/desktop devices</li>
                <li>10 million mobile push, 1 million SMS, 5 million email daily</li>
            </ul>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 2: High-Level Design</h3>
        
        <div class="architecture-pattern">
            <h4>Different Notification Types</h4>
            <div class="metrics">
                <div class="metric-card">
                    <h4>iOS Push Notification</h4>
                    <p>Provider → APNs → iOS Device<br>Device token for targeting<br>JSON payload format</p>
                </div>
                <div class="metric-card">
                    <h4>Android Push Notification</h4>
                    <p>Provider → FCM → Android Device<br>Registration token for targeting<br>HTTP POST to FCM servers</p>
                </div>
                <div class="metric-card">
                    <h4>SMS Message</h4>
                    <p>Third-party SMS services<br>Twilio, Nexmo commonly used<br>Phone numbers for targeting</p>
                </div>
                <div class="metric-card">
                    <h4>Email</h4>
                    <p>Third-party email services<br>Sendgrid, Mailchimp commonly used<br>Email addresses for targeting</p>
                </div>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Contact Info Gathering Flow</h4>
            <div class="key-points">
                <ul>
                    <li>User installs app or signs up</li>
                    <li>API servers collect device tokens, phone numbers, email</li>
                    <li>Store in database for later use</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Notification Sending Flow</h4>
            <div class="key-points">
                <ul>
                    <li>Service calls notification API</li>
                    <li>Notification service validates and sends to third-party services</li>
                    <li>Third-party services deliver to user devices</li>
                </ul>
            </div>
        </div>
        
        <div class="highlight">
            <strong>Problems with Simple Design:</strong><br>
            - Single point of failure<br>
            - Hard to scale<br>
            - Performance bottleneck
        </div>
    </div>
    
    <div class="section">
        <h3>Step 3: Design Deep Dive</h3>
        
        <div class="architecture-pattern">
            <h4>Reliability</h4>
            <div class="key-points">
                <ul>
                    <li>Data loss prevention: persist notification log</li>
                    <li>Notification retry mechanism</li>
                    <li>At-least-once delivery guarantee</li>
                    <li>Deduplication to prevent duplicates</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Additional Components</h4>
            <div class="metrics">
                <div class="metric-card">
                    <h4>Notification Template</h4>
                    <p>Avoid building format from scratch<br>Consistent formatting<br>Personalization support</p>
                </div>
                <div class="metric-card">
                    <h4>Notification Setting</h4>
                    <p>Users can opt-out<br>Fine-grained settings<br>Delivery time preferences</p>
                </div>
                <div class="metric-card">
                    <h4>Rate Limiting</h4>
                    <p>Prevent spam<br>Limit notifications per user<br>Important messages take priority</p>
                </div>
                <div class="metric-card">
                    <h4>Retry Mechanism</h4>
                    <p>Exponential backoff<br>Circuit breaker pattern<br>Dead letter queue</p>
                </div>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Updated High-Level Design</h4>
            <div class="key-points">
                <ul>
                    <li>Multiple notification servers for reliability</li>
                    <li>Message queues for decoupling</li>
                    <li>Cache for user settings and templates</li>
                    <li>Database for metadata and logs</li>
                    <li>Analytics service for tracking</li>
                    <li>Workers for different notification types</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 4: Wrap Up</h3>
        <div class="metrics">
            <div class="metric-card">
                <h4>Reliability</h4>
                <p>Robust retry mechanism<br>Message queues for durability<br>Deduplication logic</p>
            </div>
            <div class="metric-card">
                <h4>Security</h4>
                <p>AppKey/appSecret for iOS<br>OAuth2 for Android<br>HTTPS only communication</p>
            </div>
            <div class="metric-card">
                <h4>Tracking and Monitoring</h4>
                <p>Notification analytics<br>Open rate tracking<br>System health monitoring</p>
            </div>
            <div class="metric-card">
                <h4>Respect User Settings</h4>
                <p>Opt-out mechanisms<br>Frequency controls<br>Do-not-disturb hours</p>
            </div>
        </div>
    </div>
</div>

<div id="chapter11" class="tab-content">
    <h2 class="chapter-title">Chapter 11: Design a News Feed System</h2>
    
    <div class="section">
        <h3>What is News Feed?</h3>
        <div class="key-points">
            <ul>
                <li>Continuously updating list of stories</li>
                <li>Stories from people and pages user follows</li>
                <li>Central feature of social media platforms</li>
                <li>Examples: Facebook, Instagram, Twitter</li>
            </ul>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 1: Understand the Problem</h3>
        <div class="key-points">
            <ul>
                <li>Mobile app and web application</li>
                <li>User can publish posts and see friends' posts</li>
                <li>Posts sorted by reverse chronological order</li>
                <li>User can have 5000 friends</li>
                <li>10 million DAU</li>
                <li>Fast loading (< 2 seconds)</li>
            </ul>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 2: High-Level Design</h3>
        
        <div class="architecture-pattern">
            <h4>Two Main Flows</h4>
            <div class="pros-cons">
                <div class="pros">
                    <h4>Feed Publishing</h4>
                    <ul>
                        <li>User publishes a post</li>
                        <li>Data written to cache/database</li>
                        <li>Post populated to friends' news feed</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>News Feed Building</h4>
                    <ul>
                        <li>Aggregate friends' posts</li>
                        <li>Sort by reverse chronological order</li>
                        <li>Return to user</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>News Feed APIs</h4>
            <div class="key-points">
                <ul>
                    <li>Feed Publishing API: POST /v1/me/feed</li>
                    <li>News Feed Retrieval API: GET /v1/me/feed</li>
                    <li>Authentication required</li>
                    <li>Rate limiting applied</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 3: Design Deep Dive</h3>
        
        <div class="architecture-pattern">
            <h4>Feed Publishing Deep Dive</h4>
            <div class="key-points">
                <ul>
                    <li>Web servers: Authentication and rate limiting</li>
                    <li>Fanout service: Deliver posts to friends</li>
                    <li>Notification service: Send push notifications</li>
                    <li>Post cache and database for storage</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Fanout Models</h4>
            <div class="pros-cons">
                <div class="pros">
                    <h4>Fanout on Write (Push)</h4>
                    <ul>
                        <li>Pre-compute news feed during write time</li>
                        <li>Fast retrieval</li>
                        <li>Good for users with few friends</li>
                        <li>Storage intensive for celebrities</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>Fanout on Read (Pull)</h4>
                    <ul>
                        <li>Generate news feed during read time</li>
                        <li>Slow for users with many friends</li>
                        <li>Good for celebrities</li>
                        <li>Storage efficient</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="highlight">
            <strong>Hybrid Approach:</strong> Push for most users, Pull for celebrities with many followers
        </div>
        
        <div class="architecture-pattern">
            <h4>Fanout Service</h4>
            <div class="key-points">
                <ul>
                    <li>Fetch friend IDs from graph database</li>
                    <li>Get friends info from user cache</li>
                    <li>Send friends list and post ID to message queue</li>
                    <li>Fanout workers fetch data from message queue</li>
                    <li>Store posts in news feed cache</li>
            </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>News Feed Retrieval Deep Dive</h4>
            <div class="key-points">
                <ul>
                    <li>Media content stored in CDN</li>
                    <li>News feed cached in memory for fast access</li>
                    <li>User and post data cached</li>
                    <li>Pagination support for large feeds</li>
            </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Cache Architecture</h4>
            <div class="metrics">
                <div class="metric-card">
                    <h4>News Feed Cache</h4>
                    <p>Store feed for each user<br>Key: user_id<br>Value: list of post IDs</p>
                </div>
                <div class="metric-card">
                    <h4>Content Cache</h4>
                    <p>Store post content<br>Key: post_id<br>Value: post data</p>
                </div>
                <div class="metric-card">
                    <h4>Social Graph Cache</h4>
                    <p>Store friend relationships<br>Key: user_id<br>Value: list of friend IDs</p>
                </div>
                <div class="metric-card">
                    <h4>Action Cache</h4>
                    <p>Store like, reply, share data<br>Recent actions cached<br>Historical data in database</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 4: Wrap Up</h3>
        <div class="key-points">
            <ul>
                <li>Scaling database: Vertical vs horizontal scaling</li>
                <li>SQL vs NoSQL: Both used for different purposes</li>
                <li>Master-slave replication</li>
                <li>Read replicas</li>
                <li>Consistency models</li>
                <li>Database sharding</li>
            </ul>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <h4>Monitoring</h4>
                <p>QPS and latency monitoring<br>CPU and memory usage<br>Database performance</p>
            </div>
            <div class="metric-card">
                <h4>Additional Features</h4>
                <p>Like and comment functionality<br>Media posts (images/videos)<br>Tag friends capability</p>
            </div>
        </div>
    </div>
</div>

<div id="chapter12" class="tab-content">
    <h2 class="chapter-title">Chapter 12: Design a Chat System</h2>
    
    <div class="section">
        <h3>Step 1: Understand the Problem</h3>
        <div class="key-points">
            <ul>
                <li>One-on-one and group chat</li>
                <li>Mobile and web app support</li>
                <li>50 million DAU</li>
                <li>Group chat limit: 100 people</li>
                <li>Text messages only initially</li>
                <li>Message size limit: 100,000 characters</li>
                <li>End-to-end encryption required</li>
            </ul>
        </div>
        
        <div class="formula">
            Daily messages = 50M users × 40 messages = 2 billion messages/day
        </div>
    </div>
    
    <div class="section">
        <h3>Step 2: High-Level Design</h3>
        
        <div class="architecture-pattern">
            <h4>Chat Service APIs</h4>
            <div class="key-points">
                <ul>
                    <li>Send message: POST /v1/messages</li>
                    <li>Get messages: GET /v1/messages</li>
                    <li>Real-time messaging via WebSocket</li>
                    <li>Authentication and authorization</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Communication Protocols</h4>
            <div class="pros-cons">
                <div class="pros">
                    <h4>HTTP</h4>
                    <ul>
                        <li>Good for sending messages</li>
                        <li>Client-initiated communication</li>
                        <li>Stateless protocol</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>WebSocket</h4>
                    <ul>
                        <li>Bi-directional communication</li>
                        <li>Real-time messaging</li>
                        <li>Persistent connection</li>
                        <li>Low latency</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="highlight">
            <strong>Recommendation:</strong> HTTP for sending, WebSocket for receiving messages
        </div>
    </div>
    
    <div class="section">
        <h3>Step 3: Design Deep Dive</h3>
        
        <div class="architecture-pattern">
            <h4>Service Discovery</h4>
            <div class="key-points">
                <ul>
                    <li>Client needs to find best chat server</li>
                    <li>Criteria: geographical location, server capacity</li>
                    <li>Apache Zookeeper for service registry</li>
                    <li>Consistent hashing for load balancing</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Message Flows</h4>
            <div class="metrics">
                <div class="metric-card">
                    <h4>1-on-1 Chat Flow</h4>
                    <p>User A → Chat Server → Message Queue → User B<br>Message stored in database<br>Push notification if offline</p>
                </div>
                <div class="metric-card">
                    <h4>Group Chat Flow</h4>
                    <p>User A → Chat Server → Message Queue → Multiple Users<br>Fanout to all group members<br>Message ordering important</p>
                </div>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Message Synchronization</h4>
            <div class="key-points">
                <ul>
                    <li>Each device maintains local copy</li>
                    <li>Message queue for each device</li>
                    <li>cur_max_message_id for synchronization</li>
                    <li>Long polling for real-time updates</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Small Group Chat</h4>
            <div class="key-points">
                <ul>
                    <li>New message copied to each member's message queue</li>
                    <li>Simple but doesn't scale for large groups</li>
                    <li>Works well for groups < 100 people</li>
            </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Online Presence</h4>
            <div class="key-points">
                <ul>
                    <li>Heartbeat mechanism every 30 seconds</li>
                    <li>Online status stored in presence servers</li>
                    <li>WebSocket connection status tracking</li>
                    <li>Fanout to friends when status changes</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 4: Wrap Up</h3>
        <div class="metrics">
            <div class="metric-card">
                <h4>Additional Features</h4>
                <p>Media support (photos/videos)<br>Read receipts<br>Message search functionality</p>
            </div>
            <div class="metric-card">
                <h4>Error Handling</h4>
                <p>Chat server failure handling<br>Message resend mechanism<br>Data consistency issues</p>
            </div>
            <div class="metric-card">
                <h4>Security</h4>
                <p>End-to-end encryption<br>Message authentication<br>Rate limiting per user</p>
            </div>
            <div class="metric-card">
                <h4>Storage Optimization</h4>
                <p>Compress chat history<br>Archive old messages<br>Local caching strategy</p>
            </div>
        </div>
    </div>
</div>

<div id="chapter13" class="tab-content">
    <h2 class="chapter-title">Chapter 13: Design a Search Autocomplete System</h2>
    
    <div class="section">
        <h3>Step 1: Understand the Problem</h3>
        <div class="key-points">
            <ul>
                <li>Fast response time: < 100ms</li>
                <li>Relevant suggestions based on search history</li>
                <li>Sort by popularity/relevance</li>
                <li>Scalable to handle 10 million DAU</li>
                <li>Spell check and error tolerance</li>
            </ul>
        </div>
        
        <div class="formula">
            24,000 search queries per second (10M DAU × 10 searches × 20 characters × 4 requests)
        </div>
        
        <div class="highlight">
            <strong>QPS Calculation:</strong> Peak QPS ≈ 48,000/second
        </div>
    </div>
    
    <div class="section">
        <h3>Step 2: High-Level Design</h3>
        
        <div class="architecture-pattern">
            <h4>Two Main Services</h4>
            <div class="pros-cons">
                <div class="pros">
                    <h4>Data Gathering Service</h4>
                    <ul>
                        <li>Gather user input queries</li>
                        <li>Aggregate and calculate frequencies</li>
                        <li>Store in frequency table</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>Query Service</h4>
                    <ul>
                        <li>Return top 5 suggestions</li>
                        <li>Sort by frequency</li>
                        <li>Fast response required</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Database Schema</h4>
            <div class="key-points">
                <ul>
                    <li>Query: string (primary key)</li>
                    <li>Frequency: integer</li>
                    <li>Index on query for fast lookup</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 3: Design Deep Dive</h3>
        
        <div class="architecture-pattern">
            <h4>Trie Data Structure</h4>
            <div class="key-points">
                <ul>
                    <li>Tree-like data structure for strings</li>
                    <li>Root represents empty string</li>
                    <li>Each node stores character and frequency</li>
                    <li>Fast prefix matching: O(p) where p = prefix length</li>
                </ul>
            </div>
            
            <div class="highlight">
                <strong>Optimization:</strong> Store top k suggestions at each node to avoid traversal
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Data Gathering Service Optimization</h4>
            <div class="key-points">
                <ul>
                    <li>Analytics logs: Raw data stored</li>
                    <li>Aggregators: Workers aggregate data weekly</li>
                    <li>Aggregated data: Processed frequency data</li>
                    <li>Workers: Build trie data structure</li>
                    <li>Trie cache: Distributed cache system</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Query Service Optimization</h4>
            <div class="key-points">
                <ul>
                    <li>Lightning-fast lookup from trie cache</li>
                    <li>AJAX requests for smooth UX</li>
                    <li>Browser caching</li>
                    <li>Data sampling to reduce volume</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Trie Operations</h4>
            <div class="metrics">
                <div class="metric-card">
                    <h4>Create</h4>
                    <p>Built offline weekly<br>Source: aggregated data<br>Serialized and stored</p>
                </div>
                <div class="metric-card">
                    <h4>Update</h4>
                    <p>Option 1: Update weekly<br>Option 2: Update individual nodes<br>Trade-off: consistency vs performance</p>
                </div>
                <div class="metric-card">
                    <h4>Delete</h4>
                    <p>Add filter layer<br>Remove hateful/violent queries<br>Physically remove from trie</p>
                </div>
                <div class="metric-card">
                    <h4>Scale Storage</h4>
                    <p>English: 26 characters<br>Unicode: much larger<br>Shard trie by prefix</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 4: Wrap Up</h3>
        <div class="key-points">
            <ul>
                <li>Multi-language support</li>
                <li>Real-time suggestions vs batch processing</li>
                <li>Different ranking models (trending, personalization)</li>
                <li>Monitoring and analytics</li>
            </ul>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <h4>Performance Optimization</h4>
                <p>CDN for static content<br>Regional data centers<br>Caching at multiple layers</p>
            </div>
            <div class="metric-card">
                <h4>Personalization</h4>
                <p>User search history<br>Location-based suggestions<br>Time-based trending</p>
            </div>
        </div>
    </div>
</div>

<div id="chapter14" class="tab-content">
    <h2 class="chapter-title">Chapter 14: Design YouTube</h2>
    
    <div class="section">
        <h3>Step 1: Understand the Problem</h3>
        <div class="key-points">
            <ul>
                <li>Video upload and streaming</li>
                <li>5 million hours watched daily</li>
                <li>10% of videos watched on mobile</li>
                <li>Support international users</li>
                <li>Most video resolutions and formats</li>
                <li>Encryption and video size optimization</li>
            </ul>
        </div>
        
        <div class="formula">
            Storage: 5M hours × 300MB/hour = 1.5PB daily
        </div>
        
        <div class="highlight">
            <strong>Scale:</strong> CDN essential for global video delivery
        </div>
    </div>
    
    <div class="section">
        <h3>Step 2: High-Level Design</h3>
        
        <div class="architecture-pattern">
            <h4>System Components</h4>
            <div class="key-points">
                <ul>
                    <li>CDN: Video delivery</li>
                    <li>API servers: Everything except video streaming</li>
                    <li>Metadata DB: Video metadata storage</li>
                    <li>Metadata cache: Performance optimization</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Video Upload Flow</h4>
            <div class="key-points">
                <ul>
                    <li>User uploads video to API servers</li>
                    <li>Transcode videos to different formats</li>
                    <li>Transcoded videos uploaded to CDN</li>
                    <li>API servers update metadata database</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Video Streaming Flow</h4>
            <div class="key-points">
                <ul>
                    <li>User clicks play button</li>
                    <li>API servers return video metadata</li>
                    <li>Video streaming from CDN</li>
                    <li>CDN delivers video to user</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 3: Design Deep Dive</h3>
        
        <div class="architecture-pattern">
            <h4>Video Transcoding</h4>
            <div class="key-points">
                <ul>
                    <li>Raw video format: Large size, not optimized</li>
                    <li>Encoded video: Compressed, multiple formats</li>
                    <li>Bitrate: Higher bitrate = higher quality + larger size</li>
                    <li>Common formats: MP4, WebM, MPEG, HLS</li>
                </ul>
            </div>
            
            <div class="metrics">
                <div class="metric-card">
                    <h4>Why Transcode?</h4>
                    <p>Raw video large size<br>Many devices and bandwidths<br>Network conditions vary<br>Storage cost optimization</p>
                </div>
                <div class="metric-card">
                    <h4>Encoding Formats</h4>
                    <p>Container: MP4, FLV, WebM<br>Codecs: H.264, VP9, HEVC<br>Audio: AAC, MP3<br>Resolutions: 4K, 1080p, 720p, etc.</p>
                </div>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Directed Acyclic Graph (DAG) Model</h4>
            <div class="key-points">
                <ul>
                    <li>Tasks arranged as DAG</li>
                    <li>Original video → Inspect → Video/Audio/Metadata</li>
                    <li>Video encoding: 1080p, 720p, 480p, 360p, 240p</li>
                    <li>Audio encoding: 64kbps, 128kbps</li>
                    <li>Thumbnail generation</li>
                    <li>Watermark application</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Video Transcoding Architecture</h4>
            <div class="key-points">
                <ul>
                    <li>Preprocessor: Video splitting, DAG generation, cache data</li>
                    <li>DAG scheduler: Split DAG into stages and tasks</li>
                    <li>Resource manager: Efficiently allocate workers</li>
                    <li>Task workers: Run tasks defined in DAG</li>
                    <li>Temporary storage: Store metadata, video, audio data</li>
                    <li>Encoded video: Final output stored in storage system</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>System Optimizations</h4>
            <div class="metrics">
                <div class="metric-card">
                    <h4>Speed Optimization</h4>
                    <p>Parallelize video uploading<br>Upload centers close to users<br>Split video into chunks</p>
                </div>
                <div class="metric-card">
                    <h4>Safety Optimization</h4>
                    <p>Pre-signed upload URL<br>Protect video resources<br>DRM system implementation</p>
                </div>
                <div class="metric-card">
                    <h4>Cost Optimization</h4>
                    <p>CDN for popular videos<br>Short videos kept longer<br>Encode on-demand for unpopular videos</p>
                </div>
                <div class="metric-card">
                    <h4>Error Handling</h4>
                    <p>Recoverable error: Retry operation<br>Non-recoverable error: Stop and notify<br>Dead letter queue for failed tasks</p>
                </div>
            </metrics>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 4: Wrap Up</h3>
        <div class="key-points">
            <ul>
                <li>Scale the API tier horizontally</li>
                <li>Scale the database (replication and sharding)</li>
                <li>Live streaming support</li>
                <li>Video takedowns (DMCA)</li>
            </ul>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <h4>Additional Features</h4>
                <p>Content recommendation<br>Age restriction<br>Video analytics<br>Comment system</p>
            </div>
            <div class="metric-card">
                <h4>Monitoring</h4>
                <p>Video transcoding success rate<br>System health metrics<br>User engagement analytics</p>
            </div>
        </div>
    </div>
</div></div>

<div id="chapter15" class="tab-content">
    <h2 class="chapter-title">Chapter 15: Design Google Drive</h2>
    
    <div class="section">
        <h3>Step 1: Understand the Problem</h3>
        <div class="key-points">
            <ul>
                <li>File upload and download</li>
                <li>File synchronization across devices</li>
                <li>Notifications when files edited/deleted/shared</li>
                <li>Support mobile and web platforms</li>
                <li>50 million users</li>
                <li>10GB free space per user</li>
                <li>10 million DAU</li>
            </ul>
        </div>
        
        <div class="formula">
            Storage: 50M users × 10GB = 500 Petabyte
        </div>
        
        <div class="highlight">
            <strong>QPS:</strong> Upload API: 1K, Download API: 3K
        </div>
    </div>
    
    <div class="section">
        <h3>Step 2: High-Level Design</h3>
        
        <div class="architecture-pattern">
            <h4>Key Components</h4>
            <div class="key-points">
                <ul>
                    <li>Block servers: Upload files to cloud storage</li>
                    <li>Cold storage: Store inactive data</li>
                    <li>Load balancer: Distribute requests</li>
                    <li>API servers: Handle metadata operations</li>
                    <li>Metadata database: Keep track of files, users, versions</li>
                    <li>Notification service: Inform relevant clients</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>APIs</h4>
            <div class="key-points">
                <ul>
                    <li>Upload file API: POST /files/upload?uploadType=resumable</li>
                    <li>Download file API: GET /files/download</li>
                    <li>Get file revisions: GET /files/list_revisions</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 3: Design Deep Dive</h3>
        
        <div class="architecture-pattern">
            <h4>Block Servers</h4>
            <div class="key-points">
                <ul>
                    <li>Split files into blocks (4MB each)</li>
                    <li>Each block assigned unique hash value</li>
                    <li>Hash used for deduplication</li>
                    <li>Reconstruct file by joining blocks</li>
                </ul>
            </div>
            
            <div class="highlight">
                <strong>Benefits:</strong> Delta sync, deduplication, network failure recovery
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Delta Sync</h4>
            <div class="key-points">
                <ul>
                    <li>Sync only modified blocks instead of whole file</li>
                    <li>Compare block hashes to identify changes</li>
                    <li>Upload only changed blocks</li>
                    <li>Significantly reduces sync time</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>High Consistency Requirement</h4>
            <div class="key-points">
                <ul>
                    <li>File consistency crucial for collaboration</li>
                    <li>Strong consistency model required</li>
                    <li>ACID properties for metadata operations</li>
                    <li>Relational database preferred for metadata</li>
            </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Metadata Database Schema</h4>
            <div class="metrics">
                <div class="metric-card">
                    <h4>User Table</h4>
                    <p>user_id, username, email<br>registration_date<br>last_login</p>
                </div>
                <div class="metric-card">
                    <h4>Device Table</h4>
                    <p>device_id, user_id<br>last_logged_in_at<br>device_type, device_info</p>
                </div>
                <div class="metric-card">
                    <h4>Namespace Table</h4>
                    <p>namespace_id, namespace_name<br>user_id, created_time</p>
                </div>
                <div class="metric-card">
                    <h4>File Table</h4>
                    <p>file_id, filename, size<br>namespace_id, created_time<br>modified_time, file_type</p>
                </div>
                <div class="metric-card">
                    <h4>File_version Table</h4>
                    <p>version_id, file_id<br>version_number<br>created_time, size, hash</p>
                </div>
                <div class="metric-card">
                    <h4>Block Table</h4>
                    <p>block_id, block_hash<br>block_path, size<br>version_id</p>
                </div>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Upload Flow</h4>
            <div class="key-points">
                <ul>
                    <li>Client requests to upload file</li>
                    <li>Store file metadata in metadata DB</li>
                    <li>Upload file to cloud storage via block servers</li>
                    <li>Update file upload status to "uploaded"</li>
                    <li>Notify relevant clients about file change</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Download Flow</h4>
            <div class="key-points">
                <ul>
                    <li>API servers return file metadata</li>
                    <li>Client gets block URLs from metadata</li>
                    <li>Download blocks from block servers</li>
                    <li>Construct file from downloaded blocks</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Notification Service</h4>
            <div class="key-points">
                <ul>
                    <li>Long polling for mobile clients</li>
                    <li>WebSocket for web clients</li>
                    <li>Inform relevant clients when files updated</li>
                <li>Message queue ensures reliability</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Save Storage Space</h4>
            <div class="key-points">
                <ul>
                    <li>De-duplicate data blocks</li>
                    <li>Adopt intelligent data backup strategy</li>
                    <li>Set limit on number of versions</li>
                    <li>Move infrequently used data to cold storage</li>
                </ul>
            </div>
        </div>
        
        <div class="architecture-pattern">
            <h4>Failure Handling</h4>
            <div class="metrics">
                <div class="metric-card">
                    <h4>Load Balancer Failure</h4>
                    <p>Secondary load balancer<br>Monitor primary health<br>Automatic failover</p>
                </div>
                <div class="metric-card">
                    <h4>Block Server Failure</h4>
                    <p>Multiple replicas of blocks<br>Different geographical regions<br>Quick replacement servers</p>
                </div>
                <div class="metric-card">
                    <h4>Cloud Storage Failure</h4>
                    <p>Multiple backup replicas<br>Cross-region replication<br>Version control system</p>
                </div>
                <div class="metric-card">
                    <h4>API Server Failure</h4>
                    <p>Stateless servers<br>Load balancer redistribution<br>Auto-scaling groups</p>
                </div>
                <div class="metric-card">
                    <h4>Metadata Cache Failure</h4>
                    <p>Multiple cache replicas<br>Data reconstructed from DB<br>Cache warm-up procedures</p>
                </div>
                <div class="metric-card">
                    <h4>Database Failure</h4>
                    <p>Master-slave setup<br>Cross-region backup<br>Point-in-time recovery</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Step 4: Wrap Up</h3>
        <div class="key-points">
            <ul>
                <li>Upload large files: Resumable upload protocol</li>
                <li>Online/offline support</li>
                <li>Mobile app specific optimizations</li>
            </ul>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <h4>Additional Features</h4>
                <p>File sharing permissions<br>File versioning history<br>Collaborative editing<br>Mobile offline sync</p>
            </div>
            <div class="metric-card">
                <h4>Performance Optimizations</h4>
                <p>Compression algorithms<br>CDN for file delivery<br>Caching strategies<br>Bandwidth optimization</p>
            </div>
        </div>
    </div>
</div>

    </div>
    
    <script>
        function showTab(tabName) {
            // Hide all tab contents
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all buttons
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked button
            event.target.classList.add('active');
        }
    </script>
</body>
</html>